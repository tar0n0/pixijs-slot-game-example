/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@pixi/core');

const _Group = class extends core.utils.EventEmitter {
  constructor(zIndex = 0, sorting = false) {
    super();
    this.useRenderTexture = false;
    this.useDoubleBuffer = false;
    this.sortPriority = 0;
    this.clearColor = new Float32Array([0, 0, 0, 0]);
    this.canDrawWithoutLayer = false;
    this.canDrawInParentStage = true;
    this._activeLayer = null;
    this._activeStage = null;
    this._activeChildren = [];
    this._lastUpdateId = -1;
    this.zIndex = zIndex || 0;
    this.enableSort = !!sorting;
    if (typeof sorting === "function") {
      this.on("sort", sorting);
    }
  }
  doSort(layer, sorted) {
    if (this.listeners("sort", true)) {
      for (let i = 0; i < sorted.length; i++) {
        this.emit("sort", sorted[i]);
      }
    }
    sorted.sort(_Group.compareZIndex);
  }
  static compareZIndex(a, b) {
    if (a.zOrder < b.zOrder) {
      return -1;
    }
    if (a.zOrder > b.zOrder) {
      return 1;
    }
    return a.updateOrder - b.updateOrder;
  }
  clear() {
    this._activeLayer = null;
    this._activeStage = null;
    this._activeChildren.length = 0;
  }
  _resolveChildDisplayObject(stage, displayObject) {
    this.check(stage);
    displayObject._activeParentLayer = this._activeLayer;
    if (this._activeLayer) {
      this._activeLayer._activeChildren.push(displayObject);
    } else {
      this._activeChildren.push(displayObject);
    }
  }
  _resolveLayer(stage, layer) {
    this.check(stage);
    if (this._activeLayer) {
      _Group.conflict();
    }
    this._activeLayer = layer;
    this._activeStage = stage;
  }
  check(stage) {
    if (this._lastUpdateId < _Group._layerUpdateId) {
      this._lastUpdateId = _Group._layerUpdateId;
      this.clear();
      this._activeStage = stage;
    } else if (this.canDrawInParentStage) {
      let current = this._activeStage;
      while (current && current !== stage) {
        current = current._activeParentStage;
      }
      this._activeStage = current;
      if (current === null) {
        this.clear();
      }
    }
  }
  static conflict() {
    if (_Group._lastLayerConflict + 5e3 < Date.now()) {
      _Group._lastLayerConflict = Date.now();
      console.log(`@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);
    }
  }
};
let Group = _Group;
Group._layerUpdateId = 0;
Group._lastLayerConflict = 0;

exports.Group = Group;
//# sourceMappingURL=Group.js.map
