/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var display = require('@pixi/display');
var Group = require('./Group.js');
var core = require('@pixi/core');

class LayerTextureCache {
  constructor(layer) {
    this.layer = layer;
    this.renderTexture = null;
    this.doubleBuffer = null;
    this.currentBufferIndex = 0;
    this._tempRenderTarget = null;
    this._tempRenderTargetSource = new core.Rectangle();
    this._tempRenderTargetDestination = new core.Rectangle();
  }
  init(renderer) {
    const width = renderer ? renderer.screen.width : 100;
    const height = renderer ? renderer.screen.height : 100;
    const resolution = renderer ? renderer.resolution : core.settings.RESOLUTION;
    this.renderTexture = core.RenderTexture.create({ width, height, resolution });
    if (this.layer.group.useDoubleBuffer) {
      this.doubleBuffer = [
        core.RenderTexture.create({ width, height, resolution }),
        core.RenderTexture.create({ width, height, resolution })
      ];
    }
  }
  getRenderTexture() {
    if (!this.renderTexture) {
      this.init();
    }
    return this.renderTexture;
  }
  pushTexture(renderer) {
    const screen = renderer.screen;
    if (!this.renderTexture) {
      this.init(renderer);
    }
    const rt = this.renderTexture;
    const group = this.layer.group;
    const db = this.doubleBuffer;
    if (rt.width !== screen.width || rt.height !== screen.height || rt.baseTexture.resolution !== renderer.resolution) {
      rt.baseTexture.resolution = renderer.resolution;
      rt.resize(screen.width, screen.height);
      if (db) {
        db[0].baseTexture.resolution = renderer.resolution;
        db[0].resize(screen.width, screen.height);
        db[1].baseTexture.resolution = renderer.resolution;
        db[1].resize(screen.width, screen.height);
      }
    }
    if (db) {
      db[0].framebuffer.multisample = rt.framebuffer.multisample;
      db[1].framebuffer.multisample = rt.framebuffer.multisample;
    }
    this._tempRenderTarget = renderer.renderTexture.current;
    this._tempRenderTargetSource.copyFrom(renderer.renderTexture.sourceFrame);
    this._tempRenderTargetDestination.copyFrom(renderer.renderTexture.destinationFrame);
    renderer.batch.flush();
    if (group.useDoubleBuffer) {
      let buffer = db[this.currentBufferIndex];
      if (!buffer.baseTexture._glTextures[renderer.CONTEXT_UID]) {
        renderer.renderTexture.bind(buffer, void 0, void 0);
        renderer.texture.bind(buffer);
        if (group.clearColor) {
          renderer.renderTexture.clear(group.clearColor);
        }
      }
      renderer.texture.unbind(rt.baseTexture);
      rt.baseTexture._glTextures = buffer.baseTexture._glTextures;
      rt.baseTexture.framebuffer = buffer.baseTexture.framebuffer;
      buffer = db[1 - this.currentBufferIndex];
      renderer.renderTexture.bind(buffer, void 0, void 0);
    } else {
      renderer.renderTexture.bind(rt, void 0, void 0);
    }
    if (group.clearColor) {
      renderer.renderTexture.clear(group.clearColor);
    }
    const filterStack = renderer.filter.defaultFilterStack;
    if (filterStack.length > 1) {
      filterStack[filterStack.length - 1].renderTexture = renderer.renderTexture.current;
    }
  }
  popTexture(renderer) {
    renderer.batch.flush();
    renderer.framebuffer.blit();
    const filterStack = renderer.filter.defaultFilterStack;
    if (filterStack.length > 1) {
      filterStack[filterStack.length - 1].renderTexture = this._tempRenderTarget;
    }
    renderer.renderTexture.bind(
      this._tempRenderTarget,
      this._tempRenderTargetSource,
      this._tempRenderTargetDestination
    );
    this._tempRenderTarget = null;
    const rt = this.renderTexture;
    const group = this.layer.group;
    const db = this.doubleBuffer;
    if (group.useDoubleBuffer) {
      renderer.texture.unbind(rt.baseTexture);
      this.currentBufferIndex = 1 - this.currentBufferIndex;
      const buffer = db[this.currentBufferIndex];
      rt.baseTexture._glTextures = buffer.baseTexture._glTextures;
      rt.baseTexture.framebuffer = buffer.baseTexture.framebuffer;
    }
  }
  destroy() {
    if (this.renderTexture) {
      this.renderTexture.destroy();
      if (this.doubleBuffer) {
        this.doubleBuffer[0].destroy(true);
        this.doubleBuffer[1].destroy(true);
      }
    }
  }
}
class Layer extends display.Container {
  constructor(group = null) {
    super();
    this.isLayer = true;
    this.group = null;
    this._activeChildren = [];
    this._tempChildren = null;
    this._activeStageParent = null;
    this._sortedChildren = [];
    this._tempLayerParent = null;
    this.insertChildrenBeforeActive = true;
    this.insertChildrenAfterActive = true;
    if (group) {
      this.group = group;
      this.zIndex = group.zIndex;
    } else {
      this.group = new Group.Group(0, false);
    }
    this._tempChildren = this.children;
  }
  get useRenderTexture() {
    return this.group.useRenderTexture;
  }
  set useRenderTexture(value) {
    this.group.useRenderTexture = value;
  }
  get useDoubleBuffer() {
    return this.group.useDoubleBuffer;
  }
  set useDoubleBuffer(value) {
    this.group.useDoubleBuffer = value;
  }
  get clearColor() {
    return this.group.clearColor;
  }
  set clearColor(value) {
    this.group.clearColor = value;
  }
  get sortPriority() {
    return this.group.sortPriority;
  }
  set sortPriority(value) {
    this.group.sortPriority = value;
  }
  getRenderTexture() {
    if (!this.textureCache) {
      this.textureCache = new LayerTextureCache(this);
    }
    return this.textureCache.getRenderTexture();
  }
  doSort() {
    this.group.doSort(this, this._sortedChildren);
  }
  destroy(options) {
    if (this.textureCache) {
      this.textureCache.destroy();
      this.textureCache = null;
    }
    super.destroy(options);
  }
  render(renderer) {
    if (!this.prerender(renderer)) {
      return;
    }
    if (this.group.useRenderTexture) {
      if (!this.textureCache) {
        this.textureCache = new LayerTextureCache(this);
      }
      this.textureCache.pushTexture(renderer);
    }
    this.containerRenderWebGL(renderer);
    this.postrender(renderer);
    if (this.group.useRenderTexture) {
      this.textureCache.popTexture(renderer);
    }
  }
  layerRenderCanvas(renderer) {
    if (this.prerender(renderer)) {
      this.containerRenderCanvas(renderer);
      this.postrender(renderer);
    }
  }
  _onBeginLayerSubtreeTraversal(stage) {
    const active = this._activeChildren;
    this._activeStageParent = stage;
    this.group._resolveLayer(stage, this);
    const groupChildren = this.group._activeChildren;
    active.length = 0;
    for (let i = 0; i < groupChildren.length; i++) {
      groupChildren[i]._activeParentLayer = this;
      active.push(groupChildren[i]);
    }
    groupChildren.length = 0;
  }
  _onEndLayerSubtreeTraversal() {
    const children = this.children;
    const active = this._activeChildren;
    const sorted = this._sortedChildren;
    for (let i = 0; i < active.length; i++) {
      this.emit("display", active[i]);
    }
    sorted.length = 0;
    if (this.insertChildrenBeforeActive) {
      for (let i = 0; i < children.length; i++) {
        sorted.push(children[i]);
      }
    }
    for (let i = 0; i < active.length; i++) {
      sorted.push(active[i]);
    }
    if (!this.insertChildrenBeforeActive && this.insertChildrenAfterActive) {
      for (let i = 0; i < children.length; i++) {
        sorted.push(children[i]);
      }
    }
    if (this.group.enableSort) {
      this.doSort();
    }
  }
  prerender(renderer) {
    if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer) {
      return false;
    }
    if (!this.visible) {
      this.displayOrder = 0;
      return false;
    }
    this.displayOrder = renderer.incDisplayOrder();
    if (this.worldAlpha <= 0 || !this.renderable) {
      return false;
    }
    if (this.children !== this._sortedChildren && this._tempChildren !== this.children) {
      this._tempChildren = this.children;
    }
    this._boundsID++;
    this.children = this._sortedChildren;
    this._tempLayerParent = renderer._activeLayer;
    renderer._activeLayer = this;
    return true;
  }
  postrender(renderer) {
    this.children = this._tempChildren;
    renderer._activeLayer = this._tempLayerParent;
    this._tempLayerParent = null;
  }
}
Layer.prototype.renderCanvas = Layer.prototype.layerRenderCanvas;

exports.Layer = Layer;
exports.LayerTextureCache = LayerTextureCache;
//# sourceMappingURL=Layer.js.map
