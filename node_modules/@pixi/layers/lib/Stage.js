/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Layer = require('./Layer.js');
var Group = require('./Group.js');

const _Stage = class extends Layer.Layer {
  constructor() {
    super(...arguments);
    this.isStage = true;
    this._tempGroups = [];
    this._activeLayers = [];
    this._activeParentStage = null;
  }
  clear() {
    this._activeLayers.length = 0;
    this._tempGroups.length = 0;
  }
  destroy(options) {
    this.clear();
    super.destroy(options);
  }
  updateStage() {
    this._activeParentStage = null;
    Group.Group._layerUpdateId++;
    this._updateStageInner();
  }
  updateAsChildStage(stage) {
    this._activeParentStage = stage;
    _Stage._updateOrderCounter = 0;
    this._updateStageInner();
  }
  _updateStageInner() {
    this.clear();
    this._addRecursive(this);
    const layers = this._activeLayers;
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (layer.group.sortPriority) {
        layer._onEndLayerSubtreeTraversal();
        const sorted = layer._sortedChildren;
        for (let j = 0; j < sorted.length; j++) {
          this._addRecursiveChildren(sorted[j]);
        }
      }
    }
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (!layer.group.sortPriority) {
        layer._onEndLayerSubtreeTraversal();
      }
    }
  }
  _addRecursive(displayObject) {
    if (!displayObject.visible) {
      return;
    }
    if (displayObject.isLayer) {
      const layer2 = displayObject;
      this._activeLayers.push(layer2);
      layer2._onBeginLayerSubtreeTraversal(this);
    }
    if (displayObject !== this && displayObject.isStage) {
      const stage = displayObject;
      stage.updateAsChildStage(this);
      return;
    }
    displayObject._activeParentLayer = null;
    let group = displayObject.parentGroup;
    if (group) {
      group._resolveChildDisplayObject(this, displayObject);
    }
    const layer = displayObject.parentLayer;
    if (layer) {
      group = layer.group;
      group._resolveChildDisplayObject(this, displayObject);
    }
    displayObject.updateOrder = ++_Stage._updateOrderCounter;
    if (displayObject.alpha <= 0 || !displayObject.renderable || !displayObject.layerableChildren || group && group.sortPriority) {
      return;
    }
    const children = displayObject.children;
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        this._addRecursive(children[i]);
      }
    }
  }
  _addRecursiveChildren(displayObject) {
    if (displayObject.alpha <= 0 || !displayObject.renderable || !displayObject.layerableChildren) {
      return;
    }
    const children = displayObject.children;
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        this._addRecursive(children[i]);
      }
    }
  }
};
let Stage = _Stage;
Stage._updateOrderCounter = 0;

exports.Stage = Stage;
//# sourceMappingURL=Stage.js.map
