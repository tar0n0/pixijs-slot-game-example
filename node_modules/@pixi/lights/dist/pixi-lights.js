/*!
 * @pixi/lights - v4.0.0
 * Compiled Thu, 22 Dec 2022 00:00:35 UTC
 *
 * @pixi/lights is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.lights=function(n,a,S,m){"use strict";function R(i,e=40,t,r){t=t||new Float32Array((e+1)*2),r=r||new Uint16Array(e+1);const o=Math.PI*2/e;let s=-1;r[++s]=s;for(let u=0;u<=e;++u){const c=u*2,O=o*u;t[c]=Math.cos(O)*i.radius,t[c+1]=Math.sin(O)*i.radius,r[++s]=s}return r[s]=1,{vertices:t,indices:r}}const g=new m.Group(0,!1),p=new m.Group(0,!1),P=new m.Group(0,!1);g.useRenderTexture=!0,p.useRenderTexture=!0;const T=class{constructor(){this.lastLayer=null,this.diffuseTexture=null,this.normalTexture=null}check(i){if(this.lastLayer===i)return;this.lastLayer=i;const e=i._activeStageParent,t=i;if(this.diffuseTexture=a.Texture.WHITE,this.normalTexture=a.Texture.WHITE,t.diffuseTexture&&t.normalTexture)this.diffuseTexture=t.diffuseTexture,this.normalTexture=t.normalTexture;else for(let r=0;r<e._activeLayers.length;r++){const o=e._activeLayers[r];o.group===p&&(this.normalTexture=o.getRenderTexture()),o.group===g&&(this.diffuseTexture=o.getRenderTexture())}}};let h=T;h._instance=new T;const V=class extends a.Quad{update(i){const e=this.buffers[0].data,t=i.x,r=i.y,o=i.x+i.width,s=i.y+i.height;(e[0]!==t||e[1]!==r||e[4]!==o||e[5]!==s)&&(e[0]=e[6]=t,e[1]=e[3]=r,e[2]=e[4]=o,e[5]=e[7]=s,this.buffers[0].update())}};let x=V;x._instance=new V;class f extends S.Mesh{constructor(e=5066073,t=.8,r,o,s){super(o?new a.Geometry().addAttribute("aVertexPosition",o).addIndex(s):x._instance,r),this.shaderName=null,this.lastLayer=null,this.blendMode=a.BLEND_MODES.ADD;const u=!o;this.drawMode=u?a.DRAW_MODES.TRIANGLE_STRIP:a.DRAW_MODES.TRIANGLES,this.lightHeight=.075,this.falloff=[.75,3,20],this.useViewportQuad=u,this.tint=e!=null?e:5066073,this.brightness=t,this.parentGroup=P}get color(){return this.tint}set color(e){this.tint=e}get falloff(){return this.material.uniforms.uLightFalloff}set falloff(e){this.material.uniforms.uLightFalloff[0]=e[0],this.material.uniforms.uLightFalloff[1]=e[1],this.material.uniforms.uLightFalloff[2]=e[2]}syncShader(e){const{uniforms:t}=this.shader;t.uViewSize[0]=e.screen.width,t.uViewSize[1]=e.screen.height,t.uViewPixels[0]=e.view.width,t.uViewPixels[1]=e.view.height,t.uFlipY=!e.framebuffer.current,t.uSampler=h._instance.diffuseTexture,t.uNormalSampler=h._instance.normalTexture,t.uUseViewportQuad=this.useViewportQuad,t.uBrightness=this.brightness}_renderDefault(e){if(!this._activeParentLayer)return;h._instance.check(this._activeParentLayer);const t=this.shader;t.alpha=this.worldAlpha,t.update&&t.update(),e.batch.flush(),t.uniforms.translationMatrix=this.transform.worldTransform.toArray(!0),this.useViewportQuad&&this.geometry.update(e.screen),this.syncShader(e),e.shader.bind(t),e.state.set(this.state),e.geometry.bind(this.geometry,t),e.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)}}const D=`vec3 intensity = diffuse * attenuation;
vec4 diffuseColor = texture2D(uSampler, texCoord);
vec3 finalColor = diffuseColor.rgb * intensity;

gl_FragColor = vec4(finalColor, diffuseColor.a);
`,w=`uniform sampler2D uSampler;
uniform sampler2D uNormalSampler;

uniform mat3 translationMatrix;

uniform vec2 uViewPixels;   // size of the viewport, in pixels
uniform vec2 uViewSize;     // size of the viewport, in CSS

uniform vec4 uColor;   // light color, alpha channel used for intensity.
uniform float uBrightness;
uniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)
uniform float uLightHeight; // light height above the viewport
uniform float uFlipY;             // whether we use renderTexture, FBO is flipped
`,C=`// normalize vectors
vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);
vec3 L = normalize(lightVector);

// pre-multiply light color with intensity
// then perform "N dot L" to determine our diffuse
vec3 diffuse = uColor.rgb * uBrightness * max(dot(N, L), 0.0);
`,y=`vec2 texCoord = gl_FragCoord.xy / uViewPixels;
texCoord.y = (1.0 - texCoord.y) * uFlipY + texCoord.y * (1.0 - uFlipY); // FBOs positions are flipped.
`,v=`vec4 normalColor = texture2D(uNormalSampler, texCoord);
normalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.

// bail out early when normal has no data
if (normalColor.a == 0.0) discard;
`,$=`attribute vec2 aVertexPosition;

uniform bool uUseViewportQuad;
uniform mat3 translationMatrix;
uniform mat3 projectionMatrix;

void main(void) {
    if (uUseViewportQuad) {
        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    }
    else
    {
        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    }
}
`;var N=Object.defineProperty,z=Object.defineProperties,G=Object.getOwnPropertyDescriptors,_=Object.getOwnPropertySymbols,E=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable,F=(i,e,t)=>e in i?N(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Q=(i,e)=>{for(var t in e||(e={}))E.call(e,t)&&F(i,t,e[t]);if(_)for(var t of _(e))j.call(e,t)&&F(i,t,e[t]);return i},H=(i,e)=>z(i,G(e));class l extends S.MeshMaterial{constructor(e){const t={translationMatrix:a.Matrix.IDENTITY.toArray(!0),uNormalSampler:a.Texture.WHITE,uViewSize:new Float32Array(2),uViewPixels:new Float32Array(2),uLightFalloff:new Float32Array([0,0,0]),uLightHeight:.075,uBrightness:1,uUseViewportQuad:!0};Object.assign(t,e==null?void 0:e.uniforms),super(a.Texture.WHITE,H(Q({},e),{uniforms:t}))}}l.defaultVertexSrc=$;const B=`precision highp float;

${w}

void main(void)
{
${y}
${v}
    // simplified lambert shading that makes assumptions for ambient color
    vec3 diffuse = uColor.rgb * uBrightness;
    vec4 diffuseColor = texture2D(uSampler, texCoord);
    vec3 finalColor = diffuseColor.rgb * diffuse;

    gl_FragColor = vec4(finalColor, diffuseColor.a);
}
`,M=class extends l{constructor(){super({program:M._program})}};let L=M;L._program=new a.Program(l.defaultVertexSrc,B);class W extends f{constructor(e=16777215,t=.5){super(e,t,new L)}}const U=`precision highp float;

// imports the common uniforms like samplers, and ambient color
${w}

uniform float uLightRadius;

void main()
{
${y}
${v}

    vec2 lightPosition = translationMatrix[2].xy / uViewSize;

    // the directional vector of the light
    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);

    // correct for aspect ratio
    lightVector.x *= uViewSize.x / uViewSize.y;

    // compute Distance
    float D = length(lightVector);

    // bail out early when pixel outside of light sphere
    if (D > uLightRadius) discard;

${C}

    // calculate attenuation
    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));

${D}
}
`,I=class extends l{constructor(){super({program:I._program,uniforms:{uLightRadius:1}})}};let d=I;d._program=new a.Program(l.defaultVertexSrc,U);class X extends f{constructor(e=16777215,t=1,r=1/0){if(r!==1/0){const o=new a.Circle(0,0,r),{vertices:s,indices:u}=R(o);super(e,t,new d,s,u),this.drawMode=a.DRAW_MODES.TRIANGLE_FAN}else super(e,t,new d);this.shaderName="pointLightShader",this.radius=r}get radius(){return this.material.uniforms.uLightRadius}set radius(e){this.material.uniforms.uLightRadius=e}}const Y=`precision highp float;

// imports the common uniforms like samplers, and ambient/light color
${w}

uniform vec2 uLightDirection;

void main()
{
${y}
${v}

    // the directional vector of the light
    vec3 lightVector = vec3(uLightDirection, uLightHeight);

    // compute Distance
    float D = length(lightVector);

${C}

    // calculate attenuation
    float attenuation = 1.0;

${D}
}
`,A=class extends l{constructor(){super({program:A._program,uniforms:{uLightRadius:1,uLightDirection:new a.Point}})}};let b=A;b._program=new a.Program(l.defaultVertexSrc,Y);class k extends f{constructor(e=16777215,t=1,r){super(e,t,new b),this.target=r}syncShader(e){super.syncShader(e);const t=this.material.uniforms.uLightDirection,r=this.worldTransform,o=this.target.worldTransform;let s,u;o?(s=o.tx,u=o.ty):(s=this.target.x,u=this.target.y),t.x=r.tx-s,t.y=r.ty-u;const c=Math.sqrt(t.x*t.x+t.y*t.y);t.x/=c,t.y/=c}}return n.AmbientLight=W,n.AmbientLightShader=L,n.DirectionalLight=k,n.DirectionalLightShader=b,n.LayerFinder=h,n.Light=f,n.LightShader=l,n.PointLight=X,n.PointLightShader=d,n.ViewportQuad=x,n.diffuseGroup=g,n.lightGroup=P,n.normalGroup=p,Object.defineProperty(n,"__esModule",{value:!0}),n}({},PIXI,PIXI,PIXI.layers);
//# sourceMappingURL=pixi-lights.js.map
