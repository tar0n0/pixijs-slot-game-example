{"version":3,"file":"point.frag.mjs","sources":["../../../src/lights/pointLight/point.frag.ts"],"sourcesContent":["import { combine, commonUniforms, computeDiffuse, computeVertexPosition, loadNormals } from '../shared';\n\nexport const pointFrag = `precision highp float;\n\n// imports the common uniforms like samplers, and ambient color\n${commonUniforms}\n\nuniform float uLightRadius;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n${combine}\n}\n`;\n"],"names":[],"mappings":";;;;;;;;;;;MAEa,YAAY;AAAA;AAAA;AAAA,EAGvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;;;;"}