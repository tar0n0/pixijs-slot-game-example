{"version":3,"file":"shared.js","sources":["../../src/lights/shared.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-inferrable-types */\nexport const combine: string = `vec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n`;\n\nexport const commonUniforms: string = `uniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewPixels;   // size of the viewport, in pixels\nuniform vec2 uViewSize;     // size of the viewport, in CSS\n\nuniform vec4 uColor;   // light color, alpha channel used for intensity.\nuniform float uBrightness;\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\nuniform float uFlipY;             // whether we use renderTexture, FBO is flipped\n`;\n\nexport const computeDiffuse: string = `// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform \"N dot L\" to determine our diffuse\nvec3 diffuse = uColor.rgb * uBrightness * max(dot(N, L), 0.0);\n`;\n\nexport const computeVertexPosition: string = `vec2 texCoord = gl_FragCoord.xy / uViewPixels;\ntexCoord.y = (1.0 - texCoord.y) * uFlipY + texCoord.y * (1.0 - uFlipY); // FBOs positions are flipped.\n`;\n\nexport const loadNormals: string = `vec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n`;\n\nexport const vert: string = `attribute vec2 aVertexPosition;\n\nuniform bool uUseViewportQuad;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main(void) {\n    if (uUseViewportQuad) {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n    else\n    {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n}\n`;\n"],"names":[],"mappings":";;;;;;;;;;;;;MACa,UAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;MAOlB,iBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;MAezB,iBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;MASzB,wBAAgC;AAAA;AAAA;MAIhC,cAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;MAOtB,OAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;"}