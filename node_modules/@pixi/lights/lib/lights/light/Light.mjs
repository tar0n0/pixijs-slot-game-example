/*!
 * @pixi/lights - v4.0.0
 * Compiled Thu, 22 Dec 2022 00:00:35 UTC
 *
 * @pixi/lights is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
import { Geometry, BLEND_MODES, DRAW_MODES } from '@pixi/core';
import { Mesh } from '@pixi/mesh';
import { lightGroup, LayerFinder } from '../../LayerFinder.mjs';
import { ViewportQuad } from './ViewportQuad.mjs';

class Light extends Mesh {
  constructor(color = 5066073, brightness = 0.8, material, vertices, indices) {
    super(!vertices ? ViewportQuad._instance : new Geometry().addAttribute("aVertexPosition", vertices).addIndex(indices), material);
    this.shaderName = null;
    this.lastLayer = null;
    this.blendMode = BLEND_MODES.ADD;
    const useViewportQuad = !vertices;
    this.drawMode = useViewportQuad ? DRAW_MODES.TRIANGLE_STRIP : DRAW_MODES.TRIANGLES;
    this.lightHeight = 0.075;
    this.falloff = [0.75, 3, 20];
    this.useViewportQuad = useViewportQuad;
    this.tint = color ?? 5066073;
    this.brightness = brightness;
    this.parentGroup = lightGroup;
  }
  get color() {
    return this.tint;
  }
  set color(val) {
    this.tint = val;
  }
  get falloff() {
    return this.material.uniforms.uLightFalloff;
  }
  set falloff(value) {
    this.material.uniforms.uLightFalloff[0] = value[0];
    this.material.uniforms.uLightFalloff[1] = value[1];
    this.material.uniforms.uLightFalloff[2] = value[2];
  }
  syncShader(renderer) {
    const { uniforms } = this.shader;
    uniforms.uViewSize[0] = renderer.screen.width;
    uniforms.uViewSize[1] = renderer.screen.height;
    uniforms.uViewPixels[0] = renderer.view.width;
    uniforms.uViewPixels[1] = renderer.view.height;
    uniforms.uFlipY = !renderer.framebuffer.current;
    uniforms.uSampler = LayerFinder._instance.diffuseTexture;
    uniforms.uNormalSampler = LayerFinder._instance.normalTexture;
    uniforms.uUseViewportQuad = this.useViewportQuad;
    uniforms.uBrightness = this.brightness;
  }
  _renderDefault(renderer) {
    if (!this._activeParentLayer) {
      return;
    }
    LayerFinder._instance.check(this._activeParentLayer);
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    if (this.useViewportQuad) {
      this.geometry.update(renderer.screen);
    }
    this.syncShader(renderer);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
}

export { Light };
//# sourceMappingURL=Light.mjs.map
