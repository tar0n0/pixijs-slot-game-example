/*!
 * @pixi/lights - v4.0.0
 * Compiled Thu, 22 Dec 2022 00:00:35 UTC
 *
 * @pixi/lights is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@pixi/core');
var mesh = require('@pixi/mesh');
var LayerFinder = require('../../LayerFinder.js');
var ViewportQuad = require('./ViewportQuad.js');

class Light extends mesh.Mesh {
  constructor(color = 5066073, brightness = 0.8, material, vertices, indices) {
    super(!vertices ? ViewportQuad.ViewportQuad._instance : new core.Geometry().addAttribute("aVertexPosition", vertices).addIndex(indices), material);
    this.shaderName = null;
    this.lastLayer = null;
    this.blendMode = core.BLEND_MODES.ADD;
    const useViewportQuad = !vertices;
    this.drawMode = useViewportQuad ? core.DRAW_MODES.TRIANGLE_STRIP : core.DRAW_MODES.TRIANGLES;
    this.lightHeight = 0.075;
    this.falloff = [0.75, 3, 20];
    this.useViewportQuad = useViewportQuad;
    this.tint = color ?? 5066073;
    this.brightness = brightness;
    this.parentGroup = LayerFinder.lightGroup;
  }
  get color() {
    return this.tint;
  }
  set color(val) {
    this.tint = val;
  }
  get falloff() {
    return this.material.uniforms.uLightFalloff;
  }
  set falloff(value) {
    this.material.uniforms.uLightFalloff[0] = value[0];
    this.material.uniforms.uLightFalloff[1] = value[1];
    this.material.uniforms.uLightFalloff[2] = value[2];
  }
  syncShader(renderer) {
    const { uniforms } = this.shader;
    uniforms.uViewSize[0] = renderer.screen.width;
    uniforms.uViewSize[1] = renderer.screen.height;
    uniforms.uViewPixels[0] = renderer.view.width;
    uniforms.uViewPixels[1] = renderer.view.height;
    uniforms.uFlipY = !renderer.framebuffer.current;
    uniforms.uSampler = LayerFinder.LayerFinder._instance.diffuseTexture;
    uniforms.uNormalSampler = LayerFinder.LayerFinder._instance.normalTexture;
    uniforms.uUseViewportQuad = this.useViewportQuad;
    uniforms.uBrightness = this.brightness;
  }
  _renderDefault(renderer) {
    if (!this._activeParentLayer) {
      return;
    }
    LayerFinder.LayerFinder._instance.check(this._activeParentLayer);
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    if (this.useViewportQuad) {
      this.geometry.update(renderer.screen);
    }
    this.syncShader(renderer);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
}

exports.Light = Light;
//# sourceMappingURL=Light.js.map
